//! Parser for the `cryo` language.
//!
//! A parser turns intermediate tokens generated by the lexer into an AST (Abstract Syntax Tree), which is then used in further operations such as type analysis and IR generation.
#![feature(array_try_from_fn)]
#![feature(generic_const_exprs)]
#![allow(private_bounds, private_interfaces, missing_docs, incomplete_features)]

pub mod atoms;
pub mod expr;
#[cfg(test)]
mod test_util;
// pub mod ident;
use cryo_lexer::stream::{Guard, StreamLike, TokenStream, TokenStreamError};
use cryo_span::{Span, Spanned};
use derive_more::From;

type ParseResult<T> = Result<T, ParseError>;

#[derive(From, Debug, PartialEq, Eq)]
pub enum ParseError {
    TokenStreamError(TokenStreamError),
}

trait Parse: Sized {
    fn parse(tokens: &mut Guard) -> ParseResult<Self>;
}

pub fn parse<T>(stream: &mut impl StreamLike) -> ParseResult<T>
where
    T: Parse,
{
    stream.with(T::parse)
}

pub struct Parser<'source> {
    stream: TokenStream<'source>,
}

impl<'source> Parser<'source> {
    pub fn spanning<T>(&mut self) -> Result<Spanned<T>, ParseError>
    where
        T: Parse,
    {
        let cursor_before = self.stream.cursor();
        let result = self.stream.with(T::parse)?;
        let final_span = self.stream.all()[cursor_before..self.stream.cursor()]
            .iter()
            .fold(Span::ZERO, |b, token| b + token.span);

        Ok(Spanned::new(result, final_span))
    }
}
