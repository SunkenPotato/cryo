//! Parser for the `cryo` language.
//!
//! A parser turns intermediate tokens generated by the lexer into an AST (Abstract Syntax Tree), which is then used in further operations such as type analysis and IR generation.
#![allow(private_bounds, private_interfaces)]

pub mod atoms;
pub mod error;
pub mod expr;
pub mod parser;
pub mod stmt;

use cryo_span::Spanned;

type S<T> = Spanned<T>;

#[cfg(test)]
mod test_util {
    use std::fmt::Debug;

    use cryo_lexer::{lexer, stream::TokenStream};

    use crate::{S, error::ParseError, parser::Parse};

    #[track_caller]
    pub(crate) fn assert_parse<T>(mut tokens: TokenStream, expect: S<T::Output>)
    where
        T: Parse,
        T::Output: Debug + PartialEq,
    {
        let result = tokens.with(T::parse);

        match result {
            Ok(v) => assert_eq!(v, expect),
            Err(e) => {
                panic!("parse failed: {e:#?}")
            }
        }
    }

    #[track_caller]
    pub(crate) fn assert_parse_fail<T>(mut tokens: TokenStream, expect: impl ParseError + Debug)
    where
        T: Parse,
        T::Output: Debug,
    {
        let result = tokens.with(T::parse);
        match result {
            Ok(v) => panic!("parsing succeded: {v:?}"),
            Err(e) => assert_eq!(&*e, &expect),
        }
    }

    #[track_caller]
    pub(crate) fn stream(input: &str) -> TokenStream {
        lexer(input).unwrap()
    }
}
