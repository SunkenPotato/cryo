//! Parser for the `cryo` language.
//!
//! A parser turns intermediate tokens generated by the lexer into an AST (Abstract Syntax Tree), which is then used in further operations such as type analysis and IR generation.
#![feature(array_try_from_fn)]
#![feature(generic_const_exprs)]
#![expect(private_bounds, incomplete_features)]

pub mod atoms;
pub mod expr;
pub mod ident;
pub mod item;
pub mod path;
pub mod stmt;

#[cfg(test)]
mod test_util;

use cryo_lexer::{
    Symbol,
    stream::{Guard, StreamLike, TokenStream, TokenStreamError},
};
use cryo_span::Spanned;
use derive_more::From;
use item::Item;

type ParseResult<T> = Result<T, ParseError>;
type SpannedParseResult<T> = Result<Spanned<T>, ParseError>;

/// Fatal errors that can occur when parsing.
#[derive(From, Debug, PartialEq, Eq)]
pub enum ParseError {
    /// The token stream returned an error.
    TokenStreamError(TokenStreamError),
    /// A keyword is missing.
    MissingKw(Spanned<Symbol>),
    /// The parser could not make any progress.
    NoProgress,
}

trait Parse: Sized {
    fn parse(tokens: &mut Guard) -> ParseResult<Self>;
}

impl Parse for () {
    fn parse(_: &mut Guard) -> ParseResult<Self> {
        Ok(())
    }
}

impl<T: Parse> Parse for Vec<Spanned<T>> {
    fn parse(parser: &mut Guard) -> ParseResult<Self> {
        let mut buf = vec![];

        while let Ok(v) = parser.spanning(T::parse) {
            buf.push(v);
        }

        Ok(buf)
    }
}

/// A series of `T` punctuated by `P`. The last `T` does not have to be followed by `P`, in which case the `inner` field will be empty and the `T` will be stored in `last`.
#[derive(Debug, PartialEq, Eq)]
pub struct Punctuated<T, P> {
    /// The series of `T` followed by `P`.
    pub inner: Vec<(Spanned<T>, Spanned<P>)>,
    /// The last `T`, which does not have to be followed by a `P`. If it were followed by `P`, it would be stored in `inner`.
    pub last: Option<Box<Spanned<T>>>,
}

impl<T, P> Punctuated<T, P> {
    /// Parse with the given closures. This is often not what you want, instead see [`Punctuated::parse`].
    pub fn parse_with<FT, FP>(tokens: &mut Guard, mut ft: FT, mut fp: FP) -> ParseResult<Self>
    where
        FT: FnMut(&mut Guard) -> ParseResult<T>,
        FP: FnMut(&mut Guard) -> ParseResult<P>,
    {
        let mut inner = vec![];
        let mut last = None;

        while let Ok(t) = tokens.spanning(&mut ft) {
            match tokens.spanning(&mut fp) {
                Ok(p) => inner.push((t, p)),
                Err(_) => {
                    last.replace(Box::new(t));
                    break;
                }
            }
        }

        Ok(Self { inner, last })
    }
}

impl<T: Parse, P: Parse> Parse for Punctuated<T, P> {
    fn parse(tokens: &mut Guard) -> ParseResult<Self> {
        Self::parse_with(tokens, T::parse, P::parse)
    }
}

impl<T> From<Punctuated<T, ()>> for Vec<Spanned<T>> {
    fn from(mut value: Punctuated<T, ()>) -> Vec<Spanned<T>> {
        let mut vec = value
            .inner
            .into_iter()
            .map(|v| v.0)
            .collect::<Vec<Spanned<T>>>();

        if let Some(v) = value.last.take() {
            vec.push(*v);
        }

        vec
    }
}

/// Parse a `T` from a stream or a guard.
pub fn parse<T>(stream: &mut impl StreamLike) -> SpannedParseResult<T>
where
    T: Parse,
{
    stream.spanning(T::parse)
}

/// An abstract syntax tree for a program.
pub struct AbstractSyntaxTree {
    /// The top-level items.
    pub items: Vec<Item>,
}

/// The parser.
pub struct Parser {
    stream: TokenStream,
}

impl Parser {
    /// Create a parser from a given stream.
    pub const fn new(stream: TokenStream) -> Self {
        Self { stream }
    }

    /// Parse the contained tokens into an [`AbstractSyntaxTree`].
    pub fn parse(mut self) -> Result<AbstractSyntaxTree, ParseError> {
        let mut items = vec![];

        while !self.stream.remaining().is_empty() {
            items.push(self.stream.with(Item::parse)?);
        }

        Ok(AbstractSyntaxTree { items })
    }
}
